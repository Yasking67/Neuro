#include <iostream>
#include <typeinfo>
#include <queue>
#include <iterator>
#include <vector>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <chrono>

#include <opencv2/core.hpp>
#include <opencv2/dnn.hpp>
#include <opencv2/dnn/all_layers.hpp>

#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>

using namespace cv;
using namespace std;

class RunYOLOonCPU {
public:

    const cv::Scalar colors = { 0, 0, 255 };
    std::tuple<cv::Mat,int, std::vector<cv::Rect>> output_tuple;

    std::vector<std::string> get_labels(std::string labels_path)
    {
    /*????? ????????? ???? ???????*/
    /*
    args:
    label_path - ?????? ???? ? ????? ???????? ??????? ???? ___.names (????? ??????/, ? ?? \)
                 ? ???? std::string
    returns:
    class_names - ?????? ????? (???? ???????) std::vector<std::string>

    */
        std::vector<std::string> class_names;
        std::ifstream class_file(labels_path);
        std::string line;

        while (std::getline(class_file, line))
            class_names.push_back(line);

        std::cout << "[INFO] There are following classes: " << "\n";

        for (int i = 0; i < class_names.size(); i++)
        {
            std::cout << class_names[i] << " ";
        }
        std::cout << "\n";
        return class_names;
    }

    cv::dnn::dnn4_v20201117::Net load_model(std::string config_path, std::string weights_path, bool GPU_RUN)
    {
    /*????? ???????? ??????*/
    /*
    args:
    label_path   - ?????? ???? ? ????? ???????????? ????? Darknet ???? ___.cfg (????? ?????? /, ? ?? \)
                   ? ???? std::string
    weights_path - ?????? ???? ? ????? ????? ????? Darknet ???? ___.weights (????? ?????? /, ? ?? \)
                   ? ???? std::string
    GPU_RUN      - bool, 1 - ???????? ?? GPU, 0 - ???????? ?? CPU

    returns:
    net  - ?????? ?????? OpenCV dnn - ??????????? ? ??????????? ?????? ?????

    */
        cv::dnn::dnn4_v20201117::Net net = cv::dnn::readNetFromDarknet(config_path, weights_path);
        std::cout << "[INFO] Model was succesfully loaded from .cfg and .weights files" << "\n";

        if (GPU_RUN)
        {
            net.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);
            net.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA);
        }
        else {
            net.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);
            net.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);
        }
        return net;
    }

    /*????? ????????? ?? ?????/????*/
    auto get_prediction(
                    cv::Mat frame,
                    cv::dnn::dnn4_v20201117::Net *pnet,
                    std::vector<std::string> labels,
                    float nmsthresh,
                    float confthresh,
                    bool SHOW_OUTPUT)
    {
    /*????? ???????? ??????*/
    /*
    args:
    frame   - ?????? cv::Mat - ????, ??????? ????????? ?? ???? ?????
                   ? ???? std::string
    *pnet   - ?????? ?? ??????????? ? ??????????? ?????? ???? - ?????? ?????? OpenCV dnn
              (??? ????????? ??????????? ~200 ??), ?????????? ??????? load_model
    labels  - ?????? ????? (???? ???????) std::vector<std::string>
    nmsthresh - ????? NMS (non maximum supression) - ?????? 0.1 - float
    confthresh - ????? ??????????? ??? ??????? ????? NMS - ?????? 0.5 - float
    SHOW_OUTPUT - bool, 1 - ????? 1 ????? (?????? ???? ?? ????? ????, ? ?? ?????), 0 - ?????????

    returns:
    output_tuple - ??????, ????????? ??:
                        1. ???? (???? ?????? ?????????, ?? ? ?????????? bbox'??) - ?????? cv::Mat
                        2. ????? ???????? ? ????? - int
                        3. ?????????? ???????(-??) - ?????? ???????? cv::Rect (std::vector<cv::Rect>)
    ?????, ??? ?????????? ??????? ????????, ?????????????? ? main(), ???????? ?????? ??????? ? C++17
    */
        std::vector<String> output_names = (*pnet).getUnconnectedOutLayersNames();
        std::vector<cv::Mat> detections;
        cv::Mat blob;
        cv::dnn::blobFromImage(frame, blob, 0.00392, cv::Size(512, 512), cv::Scalar(), true, false, CV_32F);
        (*pnet).setInput(blob);

        (*pnet).forward(detections, output_names);

        std::vector<int> indices[1];
        std::vector<cv::Rect> boxes[1];
        std::vector<float> scores[1];

        for (auto& output : detections)
        {
            const auto num_boxes = output.rows;
            for (int i = 0; i < num_boxes; i++)
            {
                auto x = output.at<float>(i, 0) * frame.cols;
                auto y = output.at<float>(i, 1) * frame.rows;
                auto width = output.at<float>(i, 2) * frame.cols;
                auto height = output.at<float>(i, 3) * frame.rows;
                cv::Rect rect(x - width / 2, y - height / 2, width, height);

                auto confidence = *output.ptr<float>(i, 5 + 0);
                if (confidence >= confthresh)
                {
                    boxes[0].push_back(rect);
                    scores[0].push_back(confidence);
                }
            }
        }

        cv::dnn::NMSBoxes(boxes[0], scores[0], 0.0, nmsthresh, indices[0]);
        int obj_number = indices[0].size();

        for (size_t i = 0; i < indices[0].size(); ++i)
        {
            const auto color = colors;

            auto idx = indices[0][i];
            const auto& rect = boxes[0][idx];
            cv::rectangle(frame, cv::Point(rect.x, rect.y), cv::Point(rect.x + rect.width, rect.y + rect.height), color, 3);

            std::ostringstream label_ss;
            label_ss << labels[0] << ": " << std::fixed << std::setprecision(2) << scores[0][idx];
            auto label = label_ss.str();

            int baseline;
            auto label_bg_sz = cv::getTextSize(label.c_str(), cv::FONT_HERSHEY_COMPLEX_SMALL, 1, 1, &baseline);
            cv::rectangle(frame, cv::Point(rect.x, rect.y - label_bg_sz.height - baseline - 10), cv::Point(rect.x + label_bg_sz.width, rect.y), color, cv::FILLED);
            cv::putText(frame, label.c_str(), cv::Point(rect.x, rect.y - baseline - 5), cv::FONT_HERSHEY_COMPLEX_SMALL, 1, cv::Scalar(0, 0, 0));
        }

        if (SHOW_OUTPUT)
        {
            cv::namedWindow("output");
            cv::imshow("output", frame);
            std::cout << typeid(frame).name() << std::endl;
//            waitKey(0);
        }

        output_tuple = make_tuple(frame,obj_number,boxes[0]);
        return output_tuple;
    }
};
